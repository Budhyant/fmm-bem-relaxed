#pragma once
/** @file Direct.hpp
 * @brief Implementation of a general, direct matrix-vector multiplication
 * where the matrix elements are generated by a kernel, K
 */

/** Compute the matrix-vector multiplication directly
 * omega_m = sum_n K(p_m,p_n) psi_n
 *
 * @param[in] K The Kernel that generates the elements of the matrix
 * @param[in] p The vector of source and target points
 * @param[in] psi The vector of "charges" in the matvec
 * @param[out] omega The result of the matvec
 */
template <typename Kernel>
void Direct_Kernel_MatVec(Kernel K,
                          const std::vector<typename Kernel::point_type>& p,
                          const std::vector<typename Kernel::charge_type>& psi,
                          std::vector<typename Kernel::range_type>& omega)
{
  int N = p.size();
  for (int m = 0; m < N; ++m) {
    omega[m] = typename Kernel::range_type();
    for (int n = 0; n != m; ++n) {
      K.P2P(p[n], psi[n], omega[n],
            p[m], psi[m], omega[m]);
    }
  }
}

/** Compute the matrix-vector multiplication directly
 * omega_m = sum_n K(t_m,s_n) psi_n
 *
 * @param[in] K The Kernel that generates the elements of the matrix
 * @param[in] s The vector of source points
 * @param[in] t The vector of target points
 * @param[in] psi The vector of "charges" in the matvec
 * @param[out] omega The result of the matvec
 */
template <typename Kernel>
void Direct_Kernel_MatVec(Kernel K,
                          const std::vector<typename Kernel::point_type>& s,
                          const std::vector<typename Kernel::point_type>& t,
                          const std::vector<typename Kernel::charge_type>& psi,
                          std::vector<typename Kernel::range_type>& omega)
{
  int Ns = s.size();
  int Nt = t.size();
  for (int m = 0; m < Ns; ++m) {
    omega[m] = typename Kernel::range_type();
    for (int n = 0; n < Nt; ++n) {
      K.P2P(t[n], s[m], psi[m], omega[m]);
    }
  }
}

// TODO: Iterator based direct methods for use in P2P...
